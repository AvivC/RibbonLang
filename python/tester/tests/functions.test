test empty_function_does_nothing
    {}
    {}()
expect
end

test function_with_no_return_returns_nil
    print({}())
    f = {

    }
    print(f())
expect
    nil
    nil
end

test function_calls
    f1 = { takes x to
        print("f1")
        return x * 10
    }
    f2 = { takes x to
        print("f2")
        return f1(x) * 10
    }
    f3 = { takes x to
        print("f3")
        return f2(x) * 10
    }
    print(f3(8))
expect
    f3
    f2
    f1
    8000
end

test fuction_calls_multi_arg
    divide = {takes x, y to
        print("In function divide")
        return x / y
    }
    print(divide(20, 5))
expect
    In function divide
    4
end

test function_as_argument
    f1 = {takes f2 to
        return f2(50)
    }

    q = { takes n to
        return n * n
    }

    print(f1(q))
expect
    2500
end

test function_call_in_expression
    f = { takes x, y to
        print("In f")
        return x + y
    }
    print(5 + 8 * f(10, f(5, 15)) - 1)
expect
    In f
    In f
    244
end

test function instances are independent objects
    func_creator = {
        return { takes food to
            print("I received a " + food)
        }
    }

    f1 = func_creator()
    f2 = func_creator()

    print(f1 == f1)
    print(f1 == f2)

    f1.attr = "Thing1"
    f2.attr = "Thing2"

    print(f1.attr)
    print(f2.attr)

    f1("pizza")
    f2("pasta")
    f1("pizza")
    f2("pasta")
    f1("steak")
    f1("orange")
expect
    true
    false
    Thing1
    Thing2
    I received a pizza
    I received a pasta
    I received a pizza
    I received a pasta
    I received a steak
    I received a orange
end

test basic closures
    outer = {
        x = 10
        inner = {
            print(x)
        }
        return inner
    }
    inner = outer()
    inner()
expect
    10
end

test deeply nested closures
    outer = {
        x = "abc"
        middle = {
            inner = {
                print(x)
            }
            return inner
        }
        return middle
    }
    middle = outer()
    inner = middle()
    inner()
expect
    abc
end

test deeply nested closures with different names
    outer = {
        x = "abc"
        middle = {
            inner = {
                print(x)
            }
            return inner
        }
        return middle
    }

    a = outer()
    b = a()
    b()
expect
    abc
end

test higher order closures
    concat = { takes value, concat_fn to
        result = concat_fn(value)
        print(result)
    }

    concat_factory = { takes x to
        return { takes y to
            return x + " " + y
        }
    }

    concat_hello = concat_factory("hello")
    concat_hi = concat_factory("hi")

    concat("Aviv", concat_hello)
    concat("Aviv", concat_hi)
expect
    hello Aviv
    hi Aviv
end

test closure semantics
    outer = {
        x = "original"
        middle = {
            inner = {
                print(x)
            }
            x = "something else"
            return inner
        }
        x = "updated"
        return middle
    }

    m = outer()
    i = m()
    i()
expect
    updated
end

test closure with arguments
    outer = {takes x to
        middle = {
            inner = {
                return x
            }
            x = "something else"
            return inner
        }
        x = "updated"
        return middle
    }

    m = outer("original")
    i = m()
    print(i())
expect
    updated
end

test function reaches to base function
    x = 200
    f = { takes n to
        return x * n
    }
    print(f(10))
expect
    2000
end

test weird closure behavior
    outer = {
        middle = {
            inner = {
                return x * 10
            }
            x = 10
            return inner
        }
        return middle
    }
    middle = outer()
    inner = middle()
    print(inner())
expect
    100
end