import graphics
import math
sdl = graphics

# print = { | text | }

MAX_FPS = 50

keyboard = [sdl.SDL_SCANCODE_UP: false,
            sdl.SDL_SCANCODE_DOWN: false,
            sdl.SDL_SCANCODE_LEFT: false,
            sdl.SDL_SCANCODE_RIGHT: false,
            sdl.SDL_SCANCODE_SPACE: false]

SCREEN_WIDTH = 1000
SCREEN_HEIGHT = 800

Player = class {
    @init = { | x, y, texture |
        self.x = x
        self.y = y
        self.dx = 0
        self.dy = 0

        self.texture = texture

        details = []
        sdl.query_texture(texture, details)
        self.width = details["w"] / 15
        self.height = details["h"] / 15
    }

    apply_force = { | fx, fy, dt |
        self.dx = self.dx + fx * dt
        self.dy = self.dy + fy * dt
    }

    apply_breaks = { | dt |
        self.apply_force(self.dx * -10, self.dy * -10, dt)
    }

    update = { | dt |
        if keyboard[sdl.SDL_SCANCODE_RIGHT] {
            self.apply_force(30, 0, dt)
        } elsif keyboard[sdl.SDL_SCANCODE_LEFT] {
            self.apply_force(-30, 0, dt)
        } else {
            self.apply_breaks(dt)
        }
        if keyboard[sdl.SDL_SCANCODE_SPACE] {
            print("shoot")
        }

        self.x = self.x + (self.dx * dt) * MAX_FPS
        self.y = self.y + (self.dy * dt) * MAX_FPS

        if math.abs(self.dy) <= 0.05 {
            self.dy = 0
        }
        if math.abs(self.dx) <= 0.05 {
            self.dx = 0
        }
    }
}

Ball = class {
    @init = { | x, y, texture |
        self.x = x
        self.y = y
        self.dx = 0
        self.dy = 0
        self.texture = texture
        
        details = []
        sdl.query_texture(texture, details)
        self.width = details["w"] / 10
        self.height = details["h"] / 10
        
        self._bounces = 0 # debugging
    }
    
    apply_force = { | fx, fy, dt |
        self.dx = self.dx + fx * dt
        self.dy = self.dy + fy * dt
    }

    update = { | dt |

        self.x = self.x + (self.dx * dt) * MAX_FPS
        self.y = self.y + (self.dy * dt) * MAX_FPS
        
        floor = SCREEN_HEIGHT - self.height
        
        if self.y >= floor {
            self.y = floor
        
            self._bounces = self._bounces + 1

            self.dy = self.dy * (-1)       
        } else {
            self.apply_force(0, 30, dt)
        }
        
    }
}

Game = class {
    _init_sdl = { | title |
        sdl.init(sdl.SDL_INIT_VIDEO)
        
        self.window = sdl.create_window(title, sdl.SDL_WINDOWPOS_UNDEFINED, sdl.SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, 0)
        
        sdl.set_hint(sdl.SDL_HINT_RENDER_SCALE_QUALITY, "linear")
        self.renderer = sdl.create_renderer(self.window, -1, sdl.SDL_RENDERER_ACCELERATED)
        
        sdl.img_init(sdl.IMG_INIT_PNG)
        sdl.show_cursor(1)
    }

    @init = { | title |
        self._init_sdl(title)

        self.ball_texture = sdl.img_load_texture(self.renderer, "sdl_extension\pictures\ball.png")
        
        player_texture = sdl.img_load_texture(self.renderer, "sdl_extension\pictures\ball.png")
        self.player = Player(SCREEN_WIDTH / 2, SCREEN_HEIGHT - 160, player_texture)
        self.balls = []
        
        self.spawn_ball()

        self.running = true
    }
    
    spawn_ball = {
        random_x = math.random_in_range(0 + 60, SCREEN_WIDTH - 60)
        texture = self.ball_texture
        self.balls[self.balls.length()] = Ball(random_x, 0, texture)
    }
    
    prepare_scene = {
        sdl.set_render_draw_color(self.renderer, 128, 230, 5, 255)
        sdl.render_clear(self.renderer)
    }
    
    present_scene = {
        sdl.render_present(self.renderer)
    }
    
    logic = { | dt |
        self.player.update(dt)

        if keyboard[sdl.SDL_SCANCODE_SPACE] {
            self.spawn_ball()
        }
        
        for ball in self.balls {
            ball.update(dt)
        }
    }
    
    draw = {
        player = self.player
        dest_rect = sdl.Rect(player.x, player.y, player.width, player.height)
        sdl.render_copy(self.renderer, player.texture, nil, dest_rect)

        for ball in self.balls {
            dest_rect = sdl.Rect(ball.x, ball.y, ball.width, ball.height)
            sdl.render_copy(self.renderer, ball.texture, nil, dest_rect)
        }
    }
    
    input = {
        event = sdl.poll_event()
        while (event != nil) {
            if event.type == sdl.SDL_QUIT {
                self.running = false
            } elsif event.type == sdl.SDL_KEYUP and event.repeat == 0 {
                keyboard[event.scancode] = false
            } elsif event.type == sdl.SDL_KEYDOWN and event.repeat == 0 {
                keyboard[event.scancode] = true
            }
            
            event = sdl.poll_event()
        }
    }
}

main = {
    game = Game("My Plane Game! :D")

    MAX_DT = 1 / MAX_FPS
    
    prev_time = 0
    curr_time = sdl.get_ticks() / 1000
    
    dbg_frame_count = 0
    dbg_frames_divided = 0
    
    while game.running {
    
        game.prepare_scene()
        
        game.input()
    
        prev_time = curr_time
        curr_time = sdl.get_ticks() / 1000
    
        frame_time = curr_time - prev_time
        
        dbg_x = 0
        while frame_time > 0 {
            dt = math.min(frame_time, MAX_DT)
            game.logic(dt)
            frame_time = frame_time - dt
            dbg_x = dbg_x + 1
        }
        if dbg_x > 0 {
            dbg_frames_divided = dbg_frames_divided + 1
        }
        
        game.draw()
        
        game.present_scene()
        
        dbg_frame_count = dbg_frame_count + 1
        
    }

    print("Balls: " + to_string(game.balls.length()))
    print("Frames: " + to_string(dbg_frame_count))
    print("dbg_frames_divided: " + to_string(dbg_frames_divided))
    print("Relation: " + to_string(dbg_frames_divided / dbg_frame_count))

}

main()